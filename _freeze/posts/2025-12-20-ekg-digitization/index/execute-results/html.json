{
  "hash": "6b483b4b3fc8175f6afc651b4b89b5f9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"EKG Digitization\"\ndate: \"2025-12-20\"\ncategories: [\"health\", \"data processing\", \"rstats\"]\nexecute:\n    warning: FALSE\nreferences:\n  - id: physionet-ecg-image-digitization\n    type: webpage\n    title: \"PhysioNet: Digitization of ECG Images\"\n    author:\n      - family: Reyna\n        given: Matthew A.\n      - given: Deepanshi\n      - family: Weigle\n        given: James\n      - family: Koscova\n        given: Zuzana\n      - family: Campbell\n        given: Kiersten\n      - family: Seyedi\n        given: Salman\n      - family: Elola\n        given: Andoni\n      - family: Bahrami Rad\n        given: Ali\n      - family: Shah\n        given: Amit J.\n      - family: Bhatia\n        given: Neal K.\n      - family: Yan\n        given: Yao\n      - family: Dane\n        given: Sohier\n      - family: Howard\n        given: Addison\n      - family: Clifford\n        given: Gari D.\n      - family: Sameni\n        given: Reza\n    issued:\n      - year: 2025\n    URL: https://kaggle.com/competitions/physionet-ecg-image-digitization\n    publisher: Kaggle\n  - id: ecg-paper-wikimedia\n    type: graphic\n    title: \"ECG Paper\"\n    author:\n      - family: Kuhn\n        given: Markus\n      - family: Stannered\n      - family: MoodyGroove\n    issued:\n      - year: 2007\n    source: Wikimedia Commons\n    URL: https://commons.wikimedia.org/wiki/File:ECG_Paper.jpg\n    rights: Public Domain\n    note: >\n      Original PowerPoint JPEG by User:MoodyGroove. Trace modified by User:Stannered.\n      Attribution consolidated from Wikimedia Commons file history.\n---\n\n\n\nI occasionally peruse available Kaggle competitions to see if there's something fun to explore. This week, I came across [this competition](https://kaggle.com/competitions/physionet-ecg-image-digitization) around converting EKG images into time series data. This piqued my interest because context can give such a big advantage over a pure ML approach. I'm going to walk through some basics of EKGs and hopefully we can extract some time series data without using any ML. That said, there is obviously a place for computer vision to do a lot of the work that I'm going to write more deterministic code for. \n\n\n![The sample EKG we will analyze](sample_ekg.png){#fig-sample fig-align=center width=75%}  \n@physionet-ecg-image-digitization\n\n### Red squares\n\nBefore even looking at the actual signal, I'm interested in the red lines. Here's a good explanation from Wikipedia. We can use the red line to build our coordinate system and from there, identify time and voltage values for the actual ekg signal.\n\n![A sample grid](ekg_grid.svg)  \n@ecg-paper-wikimedia\n\nFirst, let's pull out the red channel.\n\n\n::: {.cell}\n\n:::\n\n\n![Red channel of ECG grid](red_channel.png){#fig-red width=60% fig-align=center}\n\nI was surprised to see that we pretty much eliminated the grid here. This is still helpful though. Lets find a line with no EKG signal and no writing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## convert to a matrix\n\nred_matrix <- as.integer(image_data(red))\n\n## find the number of pixels in each row with >200 value\n\nhigh_value_rows <- red_matrix[,,1] |>\n  apply(1, function(x) sum(x > 200))\nhigh_value_rows <- tibble(count = high_value_rows) |>\n  mutate(row = max(row_number()) - row_number() + 1)\n\nempty_row_graph <- ggplot(high_value_rows, aes(x = row, y = count)) +\n  coord_flip() +\n  annotation_raster(red, xmin = 0, xmax = 1700, ymin = 0, ymax = 2200) +\n  geom_line(color = \"red\") +\n  geom_vline(aes(xintercept = 1298), color = \"blue\")\n    \nempty_row_graph\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\nFrom the plot overlay, we can now see where there is writing and signal and where there is nothing but grid. Let's now find a horizontal line without signal. I added a blue line that I'll use to measure my grid. I'll use the blue channel for this one.\n\n![Blue channel of ECG grid](blue_channel.png){#fig-blue width=60% fig-align=center}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblue_matrix <- as.integer(image_data(blue))\n\n\nhorizontal_lines <- blue_matrix[502, , 1]\n## create a 3 column tibble with one column being the row number, the second column number, and the third column the value\nhorizontal_lines <- tibble(\n  column = seq(1, 2200),\n  row = 502,\n  value = horizontal_lines)\ngrid_plot <- ggplot(horizontal_lines, aes(x = column, y = value)) +\n  geom_line()\n\ngrid_plot\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nlet's zoom in and add the blue channel underneath.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrop_blue <- image_crop(blue, \"300x95+1200+450\")\n\nzoomed_in <- grid_plot +\n  lims(x = c(1200, 1500), y = c(0, 350)) +\n  annotation_raster(crop_blue, xmin = 1200, xmax = 1500, ymin = 255, ymax = 350)\n\nzoomed_in\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nEverything lines up perfectly. We can take the indeces of our minima and calculate a time per pixel for our x-axis and a mV per pixel for our y-axis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhorizontal_lines_minima <- horizontal_lines |>\n  filter(!(column %in% c(1, 2200))) |>\n  filter(value < 20) |>\n  mutate(next_minima = lead(column)) |>\n  filter(!is.na(next_minima)) |>\n  mutate(diff = next_minima - column)\n\nbig_box_width <- mean(horizontal_lines_minima$diff)\n```\n:::\n\n\n\nThe width of one big box is 39.4 pixels, which is equal to 200ms horizontally and 0.5mV vertically. Now let's start tracing the signal itself.  \n\n### Finding the signals\n\nFor this, we're going to go back to the red channel. We'll use our previous analysis that we used to find rows that have no signal, and instead use it to find the rows that have our signals. There are 4 rows of signals. The first three have all 12 leads, and the bottom row is lead II going all the way across to be used for rate and rhythm.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbands_of_signal <- high_value_rows |>\n  filter(count < max(count)) |>\n  mutate(next_row = lead(row)) |>\n  filter(!is.na(next_row)) |>\n  mutate(band = row - next_row == 1) |>\n  group_by(temp = cumsum(!lag(band, default = TRUE))) |>\n  mutate(band = cur_group_id()) |>\n  ungroup() |>\n  select(-temp) |>\n  group_by(band) |>\n  summarize(\n    start = min(row),\n    end = max(row),\n    zero_volatage = row[which.min(count)])\n\n\nbands_of_signal_graph <- ggplot(bands_of_signal |> filter(band >= 5 & band <= 8) |> mutate(band = as.factor(band)), aes(labels = band, xmin = start, xmax = end, ymin = 0, ymax = 2200)) +\n    annotation_raster(red, xmin = 0, xmax = 1700, ymin = 0, ymax = 2200) +\n    geom_rect(aes(fill = band), alpha = 0.5) +\n    geom_vline(aes(xintercept = zero_volatage), color = \"red\") +\n    coord_flip() +\n    ylim(c(0, 2200)) +\n    xlim(c(0, 1700))\n\n\n\nbands_of_signal_graph\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nNow we've found the parts of the image that have signal and we also identified the zero voltage line. Technically, zero voltage is defined as the voltage between the T wave and the following P wave, but this approximation of counting dark pixels in each row and identifying a local maximum seems to work incredibly well. You'll notice that the bands are labeled 5-8 because I started at the top and each section of text or signal created a band. This will not always be consistent. In lead II, you can see that the label is a new band, but in the other rows, the label is included in the band. Depending on the patient, the device, and the strength of the lead connection, the amplitude of the signal can vary and overlap with the label (sometimes even overlap with the signal above or below).\n\n### Tracing the signal\n\nLet's see if we can trace the signal on the red channel. The naive approach is to find the location of the min value in each column, and when there is more than one, take the highest location. I'll also block out where the letters are so we can avoid those.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleads <- lapply(seq(5,8), function(x) {\nband <- red_matrix[(1700 - bands_of_signal$end[x]):(1700 - bands_of_signal$start[x]),,1]\nif(x != 8) {\n  band[length(band[,1]):(length(band[,1])-42), 100:150] <- 255\n  band[length(band[,1]):(length(band[,1])-42), 600:675] <- 255\n  band[length(band[,1]):(length(band[,1])-42), 1090:1150] <- 255\n  band[length(band[,1]):(length(band[,1])-42), 1590:1650] <- 255\n}\nband_tibble <- tibble(\n  column = seq(1, 2200)) |>\nmutate(row = map_int(column, function(y) bands_of_signal$end[x] - min(which(band[,y] == min(band[,y]))))) |>\nmutate(band = x)\n    }) |>\n    bind_rows()\n\n\nbands_graph <- ggplot(leads, aes(x = column, y = row, color = as.factor(band))) +\n  annotation_raster(red, xmin = 0, xmax = 2200, ymin = 0, ymax = 1700) +\n  geom_line() +\n  xlim(c(0, 2200)) +\n  ylim(c(0, 1700)) +\n  scale_color_discrete(name = \"Band\")\n\n\nbands_graph\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n### Converting to time series\n\nNow that we have our signal traced, converting it to a time series is easy. We just need to subtract the zero voltage and convert the x and y coordinates into ms and mV, respectively.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleads_time_series <- leads |>\n  left_join(bands_of_signal, by = \"band\") |>\n  mutate(\n    mV = (row - zero_volatage)/big_box_width * 0.5,\n    ms = column/big_box_width * 200)\n\n\n  lead_time_series_plot <- ggplot(leads_time_series, aes(x = ms, y = mV)) +\n    geom_line() +\n    facet_grid(rows = vars(band))\n\n  lead_time_series_plot\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nNow our EKG is 10 seconds long. We could probably take it further by breaking it down into each individual lead and trimming the false signal along the edges, but I think we've demonstrated how we can get this done with image processing and some basic knowledge about EKGs.\n\nThat said, there is definitely opportunity to improve this process with machine learning. We used a pretty standard PNG. The competition also includes paper scans, pictures taken with cell phones, black and white scans, etc. A robust process would be to use machine learning to get the EKG oriented correctly, colorize it into something consistent, and mark regions where the signal is and isn't (e.g. making sure the aVR label doesn't get interpreted as signal). \n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}